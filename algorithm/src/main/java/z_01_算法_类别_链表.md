#概述
![](.z_01_算法_类别_链表_images/b4201551.png)
![](.z_01_算法_类别_链表_images/72e746bb.png)
![](.z_01_算法_类别_链表_images/7820bcc5.png)
#遍历
![](.z_01_算法_类别_链表_images/53c9315e.png)
#查找
![](.z_01_算法_类别_链表_images/d82d2f1f.png)
#插入
![](.z_01_算法_类别_链表_images/eef816f9.png)
##头部插入
![](.z_01_算法_类别_链表_images/9b25c0e7.png)
##尾部插入
![](.z_01_算法_类别_链表_images/9cf5643e.png)
![](.z_01_算法_类别_链表_images/2f4f4001.png)
![](.z_01_算法_类别_链表_images/96ec144f.png)
##指定节点插入
![](.z_01_算法_类别_链表_images/91b7404c.png)
#删除
![](.z_01_算法_类别_链表_images/eb41cb1d.png)
![](.z_01_算法_类别_链表_images/75971028.png)
##删除给点节点
![](.z_01_算法_类别_链表_images/651cc223.png)
虚拟头结点优化
![](.z_01_算法_类别_链表_images/844d18e8.png)
![](.z_01_算法_类别_链表_images/9f282603.png)
![](.z_01_算法_类别_链表_images/132fa5b2.png)
![](.z_01_算法_类别_链表_images/c2986373.png)
#解题技巧
![](.z_01_算法_类别_链表_images/d2d5ef87.png)
![](.z_01_算法_类别_链表_images/902ce9a1.png)
#例题
##手撕链表实现
![](.z_01_算法_类别_链表_images/5b4e5e91.png)
##移除链表元素(考虑头结点)
![](.z_01_算法_类别_链表_images/dfb5f13e.png)
![](.z_01_算法_类别_链表_images/a123e146.png)
![](.z_01_算法_类别_链表_images/4d01fb2f.png)
![](.z_01_算法_类别_链表_images/10ed1802.png)
##寻找中间节点
![](.z_01_算法_类别_链表_images/6268867c.png)
![](.z_01_算法_类别_链表_images/5e9cc31f.png)
![](.z_01_算法_类别_链表_images/08f1051a.png)
##翻转链表
[](https://leetcode-cn.com/problems/reverse-linked-list/)
头插法

```asp
public ListNode reverseList(ListNode head) {
        ListNode dummpy=new ListNode();
        ListNode pre=dummpy;
        while(head!=null){
            ListNode next=head.next;
            head.next=pre.next;
            pre.next=head;
            head=next;
        }
        return dummpy.next;
}
```
尾逆转
```asp
public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null)return head;
        ListNode cur=reverseList(head.next);
        head.next.next=head;
        head.next=null;
        return cur;
}
```
##328. 奇偶链表
```asp
public ListNode oddEvenList(ListNode head) {
        ListNode odd=new ListNode();
        ListNode even=new ListNode();
        ListNode odd_tail=odd;
        ListNode even_tail=even;
        while(head!=null){            
            // 奇数串联
            odd_tail.next=head;
            odd_tail=head;
            // 偶数串联
            even_tail.next=head.next;
            even_tail=head.next;
            if(head.next!=null){
                head=head.next.next;
            }else head=null;
        }
        odd_tail.next=even.next;
        return odd.next;
    }
```
##倒数第k个(两次遍历)
```asp
public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode first=new ListNode();
        first.next=head;
        while(k>0&&first!=null){
            first=first.next;
            k--;
        }
        ListNode second=new ListNode();
        second.next=head;
        while(first.next!=null){
            first=first.next;
            second=second.next;
        }
        return second.next;
    }
```
##循环链表
排好序的尾部  
当前待排序的头部和尾部  
下一个待排序的头部  
```asp
public boolean hasCycle(ListNode head) {
        if(head==null)return false;
        ListNode fast=new ListNode();
        ListNode slow=new ListNode();
        fast.next=head;
        slow.next=head;
        while(fast.next!=null&&fast.next.next!=null){
            if(fast==slow)return true;
            slow=slow.next;
            fast=fast.next.next;
        }
        return false;
    }
```
##25. K 个一组翻转链表
[](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
```asp
public ListNode reverseKGroup(ListNode head, int k) {
         ListNode dummpy=new ListNode();
         dummpy.next=head;
         ListNode tail=dummpy;
         ListNode cur=head;
         while(cur!=null){
             ListNode curr=cur;
             int count=k;
             while(count>1&&curr!=null){
                 curr=curr.next;
                 count--;
             }
             if(curr==null){
                 tail.next=cur;
                 return dummpy.next;
             }
             ListNode p=cur;
             ListNode q=curr.next;
             cur=curr.next;
             ListNode[] arr=reverse(p,q);
             tail.next=arr[0];
             tail=arr[1];
             
         }
         return dummpy.next;
    }


public ListNode[] reverse(ListNode p,ListNode q){
    ListNode dummpy=new ListNode();
    ListNode cur=p;
    ListNode tail=p;
    while(cur!=q){
        ListNode next=cur.next;
        cur.next=dummpy.next;
        dummpy.next=cur;
        cur=next;
    }
    return new ListNode[]{dummpy.next,tail};
}
```

