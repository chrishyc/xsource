#概述
![](.z_04_算法_类别_二分查找_images/4103b2ed.png)
##难点
![](.z_07_算法_类别_二分查找_images/3117d71a.png)
##模板
![](.z_07_算法_类别_二分查找_images/b40b2263.png)
![](.z_07_算法_类别_二分查找_images/026084a8.png)
[](https://www.xzgedu.com/detail/v_60bd662ae4b07e4d7fdc86ec/3?from=term_61ab909e6ab61_khvVNp&type=25&parent_pro_id=)
#代码
非递归
![](.z_04_算法_类别_二分查找_images/1d710455.png)
递归
![](.z_04_算法_类别_二分查找_images/6e54f899.png)
#时间复杂度
log(n)

#例题
![](.z_04_算法_类别_二分查找_images/8b8e0f0d.png)
##链表二分查找
##第一个最后一个
![](.z_04_算法_类别_二分查找_images/fd20a349.png)
最后一个
```asp
public int[] searchRange(int[] nums, int target) {
        int[] ans={-1,-1};
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=left+((right-left)>>1);
            if(nums[mid]<=target)left=mid+1;
            else right=mid-1;
        }
        return left-1;
    }
```
![](.z_04_算法_类别_二分查找_images/30a30ea2.png)
![](.z_04_算法_类别_二分查找_images/060f6fef.png)
第一个
```asp
```asp
public int[] searchRange(int[] nums, int target) {
        int[] ans={-1,-1};
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=left+((right-left)>>1);
            if(nums[mid]<target)left=mid+1;
            else right=mid-1;
        }
        return right+1;
    }
```

##第一个大于,最后一个小于
![](.z_04_算法_类别_二分查找_images/5c186d5a.png)
![](.z_04_算法_类别_二分查找_images/fd816f6b.png)
第一个大于:left
```asp
public int[] searchRange(int[] nums, int target) {
        int[] ans={-1,-1};
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=left+((right-left)>>1);
            if(nums[mid]<=target)left=mid+1;
            else right=mid-1;
        }
        return left;
    }
```

![](.z_04_算法_类别_二分查找_images/bf5804eb.png)
最后一个小于,right
```asp
public int[] searchRange(int[] nums, int target) {
        int[] ans={-1,-1};
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=left+((right-left)>>1);
            if(nums[mid]<target)left=mid+1;
            else right=mid-1;
        }
        return right;
    }
```
##稀疏数组
[面试题 10.05. 稀疏数组搜索](https://leetcode-cn.com/problems/sparse-array-search-lcci/)
```asp
public int findString(String[] words, String s) {
    int low = 0;
    int high = words.length - 1;
    while (low <= high) {
      int mid = (low + high) / 2;
      if (words[mid].equals(s)) {
        return mid;
      } else if (words[mid].equals("")) {
        // 随便找一边处理，能缩小有效范围就行
        if (words[low].equals(s)) return low;
        else low++;
      } else if (words[mid].compareTo(s) < 0) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return -1;
  }
```
##循环数组找x
![](.z_04_算法_类别_二分查找_images/0b836a53.png)
![](.z_04_算法_类别_二分查找_images/528d15f9.png)
位置划分
```asp
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
      int mid = (left + right) / 2;
      if (nums[mid] == target) {
        return mid;
      } else if (nums[left] <= nums[mid]) {//left side sorted
        if (target >= nums[left] && target < nums[mid]) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      } else {
        if (target > nums[mid] && target <= nums[right]) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
    }
    return -1;
  }
```
##循环数组最小值
![](.z_04_算法_类别_二分查找_images/dd75a1a3.png)
![](.z_04_算法_类别_二分查找_images/7679cf68.png)
![](.z_04_算法_类别_二分查找_images/d72fbed3.png)
```asp
public int findMin(int[] nums) {
         int left=0;
         int right=nums.length-1;
         while(left<=right){
             int mid=left+((right-left)>>1);
             if(nums[mid]>nums[nums.length-1])left=mid+1;
             else right=mid-1;
         }
         return nums[left];
    }
```
##查找峰值
![](.z_04_算法_类别_二分查找_images/4cf0534a.png)
![](.z_04_算法_类别_二分查找_images/cc79f12b.png)
##x的平方根(溢出问题)
![](.z_04_算法_类别_二分查找_images/43d295ba.png)
![](.z_04_算法_类别_二分查找_images/4b84c8ee.png)
##二维矩阵
![](.z_04_算法_类别_二分查找_images/e2d5492c.png)
```asp
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int rows = matrix.length - 1, columns = 0;
        while (rows >= 0 && columns < matrix[0].length) {
            int num = matrix[rows][columns];
            if (num == target) {
                return true;
            } else if (num > target) {
                rows--;
            } else {
                columns++;
            }
        }
        return false;
    }
}
```
