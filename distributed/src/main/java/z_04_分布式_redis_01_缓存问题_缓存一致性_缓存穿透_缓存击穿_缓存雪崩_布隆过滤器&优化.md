#临界知识
redis两大功能:缓存,数据库
redis模块化module组件概念
redis缓存一致性更新cache还是淘汰cache:读多还是写多
redis缓存一致性速度:redis查询更新<1ms,mysql查询更新<100ms
#redis缓存一致性
缓存利用率、并发、缓存 + 数据库
##核心问题
```asp
1、先更新缓存，再更新数据库；
2、先更新数据库，再更新缓存；
3、先淘汰缓存，再更新数据库；
4、先更新数据库，再淘汰缓存
```
##更新cache还是淘汰cache
主要取决于更新缓存的复杂度
数据库写入的结果是中间值，缓存的结果是计算结果
```asp
有如下两种不适合场景 更新cache
如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能
如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是也浪费性能的
```
```asp
淘汰cache
不过大部分场景下删除缓延迟删除存操作简单，并且带来的副作用只是增加了一次Cache Miss，建议作为通用的处理方式
```
##更新数据库再删除缓存vs删除缓存后更新数据库
都可能造成数据不一致,看谁的影响最小

更新数据库再删除缓存出现脏数据概率是更小点
数据库查询更新耗时<100ms
缓存查询更新耗时<1ms

缓存和数据库不一致,一般是查旧数据库,更新回旧缓存导致,删除缓存<查库<更新数据库

```asp
请求缓存刚好失效
请求A查询数据库，得一个旧值
请求B将新值写入数据库
请求B删除缓存
请求A将查到的旧值写入缓存
```
[](https://note.dolyw.com/cache/00-DataBaseConsistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98)
##写数据库成功，第二步删除缓存失败
异步消息队列重试 延时策略 双删策略,mysql中间件canal
[](https://developer.aliyun.com/article/712285)
[](https://mp.weixin.qq.com/s/4W7vmICGx6a_WX701zxgPQ)
##可以做到强一致吗？
所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。
虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。
#缓存击穿(高并发)
少量key过期,高并发
![](.z_04_分布式_redis_01_缓存问题_缓存穿透_缓存击穿_缓存雪崩_布隆过滤器&优化_images/1a3c8f52.png)
sentinel热点参数流量控制
#缓存穿透(数据库无数据)
redis做缓存,但是可能出现大量请求穿透redis,直接到达mysql，导致mysql扛不住太多连接(bio)
但是如果mysql也不存在这些请求的内容,则属于无效穿透,屏蔽这些无效穿透可以避免mysql被击穿
![](.z_04_分布式_redis_01_缓存问题_缓存穿透_缓存击穿_缓存雪崩_布隆过滤器&优化_images/4b7a1b99.png)
##缓存空值或缺省值
```asp
一旦发生缓存穿透，我们就可以针对查询的数据，在 Redis 中缓存一个空值或是和业务层协商确定的缺省值（例如，库存的缺省值可以设为 0）。
紧接着，应用发送的后续请求再进行查询时，就可以直接从 Redis 中读取空值或缺省值，返回给业务应用了，避免了把大量请求发送给数据库处理，保持了数据库的正常运行。
```
##布隆过滤器
[T_02_BloomFilter布隆过滤器_CountingFilter_CukcooFilter布谷鸟过滤器.md]
缓存mysql中的内容hash,直接通过redis就可以判断内容不存在,避免客户端请求mysql中也不存在的内容
![](.z_04_分布式_redis_01_缓存穿透_布隆过滤器&优化__images/c0c18252.png)
![](.z_04_分布式_redis_01_缓存穿透_布隆过滤器&优化__images/1fa664cd.png)
[](https://github.com/RedisBloom/RedisBloom#use-redisbloom-with-redis-cli)
当需要查询某个数据时，我们就执行刚刚说的计算过程，先得到这个数据在 bit 数组中对应的 N 个位置。紧接着，我们查看 bit 数组中这 N 个位置上的 bit 值。
只要这 N 个 bit 值有一个不为 1，这就表明布隆过滤器没有对该数据做过标记，所以，查询的数据一定没有在数据库中保存
![](.z_04_分布式_redis_01_缓存问题_缓存一致性_缓存穿透_缓存击穿_缓存雪崩_布隆过滤器&优化_images/c92212ec.png)
##布隆过滤器无法删除
[z_10_BloomFilter布隆过滤器_CountingFilter_CukcooFilter布谷鸟过滤器.md]
计数布隆过滤器
##计数布隆过滤器太大
布谷鸟过滤器
[z_10_BloomFilter布隆过滤器_CountingFilter_CukcooFilter布谷鸟过滤器.md]
#缓存雪崩(整体大量过期)
大量key过期,Redis 缓存实例发生故障宕机了

##随机过期时间
##不能随机时间:熔断+限流
sentinel熔断降级控制
数据源服务请求模型参数超时,请求数上来,导致资源占满
```asp
当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；
当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。
```
我们就避免了大量请求因缓存缺失，而积压到数据库系统，保证了数据库系统的正常运行
我们使用这两个机制，来降低雪崩对数据库和整个业务系统的影响。

##redis集群宕机导致雪崩
使用redis cluster集群模式,
raft协议自动从节点还可以切换成为主节点
hash缓存一致性
