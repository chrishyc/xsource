#临界知识
redis两大功能:缓存,数据库
redis模块化module组件概念
redis缓存一致性更新cache还是淘汰cache:读多还是写多
redis缓存一致性速度:redis查询更新<1ms,mysql查询更新<100ms
#redis缓存一致性
缓存利用率、并发、缓存 + 数据库
##核心问题
```asp
1、先更新缓存，再更新数据库；
2、先更新数据库，再更新缓存；
3、先淘汰缓存，再更新数据库；
4、先更新数据库，再淘汰缓存
```
##更新cache还是淘汰cache
主要取决于更新缓存的复杂度
数据库写入的结果是中间值，缓存的结果是计算结果
```asp
有如下两种不适合场景 更新cache
如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能
如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是也浪费性能的
```
```asp
淘汰cache
不过大部分场景下删除缓延迟删除存操作简单，并且带来的副作用只是增加了一次Cache Miss，建议作为通用的处理方式
```
##更新数据库再删除缓存vs删除缓存后更新数据库
都可能造成数据不一致,看谁的影响最小

更新数据库再删除缓存出现脏数据概率是更小点
数据库查询更新耗时<100ms
缓存查询更新耗时<1ms

缓存和数据库不一致,一般是查旧数据库,更新回旧缓存导致,删除缓存<查库<更新数据库

```asp
请求缓存刚好失效
请求A查询数据库，得一个旧值
请求B将新值写入数据库
请求B删除缓存
请求A将查到的旧值写入缓存
```
[](https://note.dolyw.com/cache/00-DataBaseConsistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98)
##写数据库成功，第二步删除缓存失败
延时策略 双删策略
[](https://developer.aliyun.com/article/712285)
[](https://mp.weixin.qq.com/s/4W7vmICGx6a_WX701zxgPQ)
##可以做到强一致吗？
所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。
虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。
#缓存击穿
少量key过期,高并发
![](.z_04_分布式_redis_01_缓存问题_缓存穿透_缓存击穿_缓存雪崩_布隆过滤器&优化_images/1a3c8f52.png)
#缓存穿透
redis做缓存,但是可能出现大量请求穿透redis,直接到达mysql，导致mysql扛不住太多连接(bio)
但是如果mysql也不存在这些请求的内容,则属于无效穿透,屏蔽这些无效穿透可以避免mysql被击穿
![](.z_04_分布式_redis_01_缓存问题_缓存穿透_缓存击穿_缓存雪崩_布隆过滤器&优化_images/4b7a1b99.png)
##布隆过滤器
[T_02_BloomFilter布隆过滤器_CountingFilter_CukcooFilter布谷鸟过滤器.md]
缓存mysql中的内容hash,直接通过redis就可以判断内容不存在,避免客户端请求mysql中也不存在的内容
![](.z_04_分布式_redis_01_缓存穿透_布隆过滤器&优化__images/c0c18252.png)
![](.z_04_分布式_redis_01_缓存穿透_布隆过滤器&优化__images/1fa664cd.png)
[](https://github.com/RedisBloom/RedisBloom#use-redisbloom-with-redis-cli)
##布隆过滤器无法删除
计数布隆过滤器
##计数布隆过滤器太大
布谷鸟过滤器
#缓存雪崩
大量key过期
##随机过期时间
##不能随机时间
![](.z_04_分布式_redis_01_缓存问题_缓存穿透_缓存击穿_缓存雪崩_布隆过滤器&优化_images/96b99699.png)
