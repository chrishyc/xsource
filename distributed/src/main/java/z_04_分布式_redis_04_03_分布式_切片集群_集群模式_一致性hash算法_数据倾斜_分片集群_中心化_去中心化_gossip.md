##纵向扩展问题
```asp
第一个问题是，当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞（比如刚刚的例子中的情况）。
不过，如果你不要求持久化保存 Redis 数据，那么，纵向扩展会是一个不错的选择。不过，这时，你还要面对第二个问题：纵向扩展会受到硬件和成本的限制。
这很容易理解，毕竟，把内存从 32GB 扩展到 64GB 还算容易，但是，要想扩充到 1TB，就会面临硬件容量和成本上的限制了
```
[](https://www.zhihu.com/question/265014061/answer/288486230)
```asp
如果你指的是 x86-64 处理器（AMD、Intel 或兼容系统），它的实际地址空间大小是 [公式]，还有 16 比特暂时没有用。不过，这样的话虚拟地址空间也有 256 TB 了。
内核空间占一半（同样是高地址区域），普通进程使用另外一半，也就是 128 TB
```
##redis切片集群(横向扩展)
![](.z_04_分布式_redis_04_03_分布式_切片集群_集群模式_一致性hash算法_数据倾斜_分片集群_中心化_去中心化_gossip_images/61f5016d.png)
![](.z_04_分布式_redis_04_03_分布式_切片集群_集群模式_一致性hash算法_数据倾斜_分片集群_中心化_去中心化_gossip_images/f07f871a.png)
###为啥用一致性hash算法
hash算法在增加节点时需要迁移的数据过多,
key/n,key/(n+1)
###Hash Slot原理(16384)
```$xslt
首先根据键值对的 key，计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，
每个模数代表一个相应编号的哈希槽。
```

####16384背后的临界知识

###如何分配?谁分配slot?
```$xslt
Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。当然， 我们也可以使用 
cluster meet 命令手动建立实例间的连接，形成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数。
```

```$xslt
假设集群中不同 Redis 实例的内存大小配置不一，如果把哈希槽均分在各个实例上，在保存相同数量的键值对时，和内存大的实例相比，内存小的实例就会有更大的容量压力。
遇到这种情况时，你可以根据不同实例的资源配置情况，使用 cluster addslots 命令手动分配哈希槽。
```
![](.z_04_分布式_redis_04_01_分布式_主从集群_主从从_备份同步_全量备份_增量备份_切片集群_一致性hash算法_数据倾斜_images/0b62eaeb.png)
###如何同步hash槽信息?gossip同步hash槽信息
Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了

###hash槽重分配
###客户端如何定位节点
在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行
当客户端请求键值对时，会先计算键所对应的哈希槽
###重定向机制
