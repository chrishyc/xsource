#临界知识
推送/拉取
长链接
长轮询
消费者负载均衡
消息消费方式(Pull和Push)
消息消费的模式(广播模式和集群模式)
流量控制(可以结合sentinel来实现，后面单独讲) 
并发线程数设置
消息的过滤(Tag、Key) TagA||TagB||TagC * null
#集群消息
```asp
- 每条消息只需要被处理一次，broker只会把消息发送给消费集群中的一个消费者
- 在消息重投时，不能保证路由到同一台机器上
- 消费状态由broker维护
```
![](.z_06_分布式_消息队列_rocketmq_03_核心功能_02_消息消费_集群消息_广播消息_images/039400a9.png)
#广播消息
```asp
- 消费进度由consumer维护

- 保证每个消费者消费一次消息

- 消费失败的消息不会重投

只有在消息模式为MessageModel.CLUSTERING集群模式时，Broker才会自动进行重试，广播消息不重试

```
![](.z_06_分布式_消息队列_rocketmq_03_核心功能_02_消息消费_集群消息_广播消息_images/ba0124d4.png)

#并行消费
#pull vs push
##push
及时,但是如果客户端消息消费慢,不好控制,容易堆积,
##pull
客户端控制自己的消费速度,但是轮询时间不好控制,时间太长访问不及时,时间太短容易对服务端造成性能影响
##长轮询(rocketmq使用)
[](https://segmentfault.com/a/1190000023854950)
```asp
长轮询本质上仍旧是轮询，它与轮询不同之处在于，当服务端接收到客户端的请求后，服务端不会立即将数据返回给客户端，而是会先将这个请求hold住，
判断服务器端数据是否有更新。如果有更新，则对客户端进行响应，如果一直没有数据，则它会在长轮询超时时间之前一直hold住请求并检测是否有数据更新，直到有数据或者超时后才返回
```
![](.z_06_分布式_消息队列_rocketmq_03_核心功能_02_消息消费_并行消费_顺序消费_集群消息_广播消息_tag_pull_push_images/952d5f23.png)
[](http://wuwenliang.net/2019/09/22/%E8%B7%9F%E6%88%91%E5%AD%A6RocektMQ%E4%B9%8B%E7%90%86%E8%A7%A3%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/)
##长链接
连接一旦建立，永远不断开，push方式推送
#消费消息
一个队列只能被一个消费者消费

##负载均衡
RocketMQ默认使用平均负载策略
![](.z_06_分布式_消息队列_rocketmq_03_核心功能_03_消息消费_负载均衡_队列路由_队列与消费者关系_并行消费_顺序消费_局部并行顺序消费_集群消息_广播消息_tag_pull_push_images/0e55e6c6.png)
###消费倾斜
consumer的数量最好和Message Queue的数量对等或者是倍数，不然可能会有消费倾斜
![](.z_06_分布式_消息队列_rocketmq_03_核心功能_03_消息消费_负载均衡_队列路由_队列与消费者关系_并行消费_顺序消费_局部并行顺序消费_集群消息_广播消息_tag_pull_push_images/e142bc91.png)
![](.z_06_分布式_消息队列_rocketmq_03_核心功能_03_消息消费_负载均衡_队列路由_队列与消费者关系_并行消费_顺序消费_局部并行顺序消费_集群消息_广播消息_tag_pull_push_images/18a563d8.png)
##消费进度
集群模式下以主题与消费组为键保存 该主题所有队列的消费进度
##重复消费
#过滤消息
在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消 息消费。
