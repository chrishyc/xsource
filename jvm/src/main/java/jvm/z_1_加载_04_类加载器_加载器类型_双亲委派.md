#临界知识
类加载器
一个加载器对应一个namespace
类加载器之间有层次关系,层次关系向上寻找
全盘委派(全盘委派是指当一个ClassLoader装载一个类时，除非显示地使用另一个ClassLoader，则该类所依赖及引用的类也由这个ClassLoader载入)
#类加载器类型
![](.z_1_加载_类装载子系统_类加载器_class初始化_images/1e3af4bd.png)
##bootstrap
![](.z_1_加载_类装载子系统_类加载器_class初始化_images/87011aea.png)
/jre/lib/rt.jar
##Extension
/jre/lib/ext.jar
##app
classpath下
##custom
#类加载触发时机
调用类方法/属性
调用实例创建过程
  
#双亲委派&双亲委派破坏
##机制
![](.z_2_类加载器_images/4da7d2cd.png)
1.findLoadedClass未找到
2.parent.loadClass递归1,2步
3.直到bootstrap还没找到,从顶部开始尝试加载
4.findClass加载,加载异常会被try catch,findClass最终由defineClass来实现,defineClass最终把二进制流转换为Class类对象
5.直到最底层classloader

```asp
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                }

                if (c == null) {
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```
```asp
protected Class findClass(String name)
            throws ClassNotFoundException {
        if (name.endsWith("_Stub")) {
            ClassWriter cw = new ClassWriter(0);
            byte[] b = cw.toByteArray();
            return defineClass(name, b, 0, b.length);
        }
        return super.findClass(name);
    }
```
双亲委派:
1.上层classloader不应该加载下层classloader中的class
2.下层不想访问上层classloader是否有class然后再决定加载
##双亲委派机制由来
处于安全考虑,string总是由bootstrap生成
##spi问题
spi的加载器是bootstrap,具体实现类不应该使用bootstrap加载,如何获取下层classloader?
创建thread时设置一个ClassLoader,可以通过thread.getContextClassLoader获取
![](.z_2_类加载器_images/68537468.png)
##打破双亲委派
破坏classloader加载顺序
1.改变loadclass,详见[jvm.MyLoader]
2.ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定
3.osgi tomcat 都有自己的模块指定classloader
#热加载
需要使用自定义类加载器加载class,并使用新的class进行invoke
