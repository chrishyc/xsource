##原子性
读/写是原子的,原子性确保指令集执行过程中,不会有其他cpu对该内存数据进行操作.

##顺序性
确定原子操作间的执行顺序

##单核cpu与多核cpu

##cpu缓存和内存

##cpu总线与缓存总线与总线控制器
##缓存数据同步机制MESI

##原子操作vs锁
原子操作通过锁总线或者锁缓存实现,原子指令访问总线被阻塞
锁=原子操作+内核线程切换

##复杂指令的原子性
[原子指令](https://www.cnblogs.com/egmkang/p/14080645.html)
```
lock(CacheLine)
v := load(obj)
v += add
store(obj, v)
release(CacheLine)
```

##自旋锁spin lock
cmpxchg原子指令实现，
1.不涉及线程上下文切换，只有自旋开销
2.不可重入
3.不应该被中断,中断后有重入死锁的风险

spin_try_lock()
spin_lock()
##读写自旋锁
[读写自旋锁实现原理](https://www.cnblogs.com/taomaomao/archive/2012/01/07/2315753.html)

##信号量
[信号量实现](https://segmentfault.com/q/1010000021303210#)
[信号量运用](https://www.cnblogs.com/roccoshi/p/13039462.html)
```
void down(struct semaphore *sem)
{
        unsigned long flags;

        raw_spin_lock_irqsave(&sem->lock, flags); // 这里面禁止了抢占
        if (likely(sem->count > 0))
                sem->count--;
        else
                __down(sem);   // 这里睡眠，重新调度
        raw_spin_unlock_irqrestore(&sem->lock, flags);
}
```
1.等待线程会睡眠，然后等待被唤醒，需要上下文切换，适合等待时间长的情况
2.
###计数信号量
###二值信号量