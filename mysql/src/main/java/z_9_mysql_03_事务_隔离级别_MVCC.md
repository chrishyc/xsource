#事务属性ACID
对象:一个系统,系统涉及好几个成员
过程:系统可以同时并行执行
a原子性:一个系统的多个成员的状态(a1,a2,a3)必须一起转移到(b1,b2,b3)状态,不能只有部分转移,部分转移则回退到原始状态
c一致性:一个系统的多个成员的状态(a1,a2,a3)必须一起转移到(c1,c2,c3)的有效状态
i隔离性:多个系统并发执行时,互相不影响
d持久性:执行结果持久化
#事务&内存&磁盘
##事务刷盘时机
##commit
##rollback
#事务并发问题
##脏写
一个事务修改了另一个未提交事务修改过的数据
这是因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏 写的情况发生
##脏读
一个事务读到了另一个未提交事务修改过的数据
##不可重复读
两次读的不一样
##幻读(Phantom)
读到了不应该读到的列，幻读问题的产生是因为某个事务读了一个范围的记录，之后别的事务在该范围内插入了新记录，
该事务再次读取该范围的记录时，可以读到新插入的记录，所以幻读问题准确的说并不是因为读取
和写入一条相同记录而产生的
```asp
在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，
就是说MVCC对于幻读的解决时不彻底的
```
[](https://juejin.cn/post/6844903799534911496#heading-9)

#事务隔离级别
![](.z_9_mysql_03_事务_隔离级别_MVCC_脏写_脏读_不可重复读_幻读_images/a4583e4b.png)
##READ UNCOMMITTED 
读到未提交的
##READ COMMITTED
读到已提交的
##REPEATABLE READ
可重复性去读，MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题中的读问题,更新删除(当前读)问题无法避免
##SERIALIZABLE
序列化
#事务状态
![](.z_10_mysql_事务_隔离级别_images/bd0b7817.png)
#快照读(提高数据库的并发查询能力) vs 当前读
[](https://juejin.cn/post/6844903799534911496#heading-16)
```asp
select 快照读
当执行select操作是innodb默认会执行快照读，会记录下这次select后的结果，之后select 的时候就会返回这次快照的数据，
即使其他事务提交了不会影响当前select的数据，这就实现了可重复读了。快照的生成当在第一次执行select的时候，也就是说假设当A开启了事务，
然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据。
之后无论再有其他事务commit都没有关系，因为快照已经生成了，后面的select都是根据快照来的。

当前读
对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。
假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。
也正是因为这样所以才导致上面我们测试的那种情况。

注意区分快照读和当前读。 当前读指的是select for update或者select in share mode，指的是在更新之前必须先查寻当前的值，因此叫当前读。 
快照读指的是在语句执行之前或者在事务开始的时候会创建一个视图，后面的读都是基于这个视图的，不会再去查询最新的值。
```

#MVCC(提高数据库的并发查询能力,三个隐式字段，undo日志、read view)

```asp
数据库并发场景有三种，分别为：

​1、读读：不存在任何问题，也不需要并发控制

​2、读写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读、幻读、不可重复读

​3、写写：有线程安全问题，可能存在更新丢失问题

​MVCC是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照，所以MVCC可以为数据库解决一下问题：

​1、在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能

​2、解决脏读、幻读、不可重复读等事务隔离问题，但是不能解决更新丢失问题
```
[z_9_mysql_02_undo_事务id_事务原子性_回滚段.md]
[](https://github.com/twitter-forks/mysql/blob/master/storage/innobase/include/read0read.h#L124)
```asp
trx_id:每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给 trx_id 隐藏列
roll_pointer:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏 列就相当于一个指针，
可以通过它来找到该记录修改前的信息

实际上insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Und o Log Segment也会被系统回收(也就是该undo
日志占用的Undo页面链表要么被重用，要么被释放)。 虽然真正的insert undo日志占用的存储空间被释放了，但是roll_pointer的值并不会被清除，
roll_po inter属性占用7个字节，第一个比特位就标记着它指向的undo日志的类型，如果该比特位的值为1时， 就代表着它zhi向的undo日志类型为insert undo。
所以我们之后在画图时都会把insert undo给去掉， 大家留意一下就好了

每次对记录进行改动，都会记录一条 undo日志 ，每条 undo日志 也都有一个 roll_pointer 属性( INSERT 操作 对应的 undo日志 没有该属性，
因为该记录并没有更早的版本)，可以将这些 undo日志 都连起来，串成一个链 表，

```
##三个隐式字段
##版本链
![](.z_9_mysql_03_事务_隔离级别_MVCC_锁_锁释放_readview视图_脏写_脏读_不可重复读_幻读_images/0d5c9836.png)
所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 版本链 ，版本链的头节点就是当 前记录最新的值。
另外，每个版本中还包含生成该版本时对应的 事务id
[mysql是怎么运行的]

##read view
核心问题就是:需要判断一下版本链中的哪个版本是当前事务可见的。为 此，设计 InnoDB 的大叔提出了一个 ReadView 的概念
read view在创建后就不会改变了
```asp
m_ids :表示在生成 ReadView 时当前系统中活跃的读写事务的 事务id 列表。
min_trx_id :表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务id ，也就是 m_ids 中的最 小值。
max_trx_id :表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。
小贴士:
注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三 个事务，之后id为3的事务提交了。
那么一个新的读事务在生成ReadView时，m_ids就包括1和2，mi n_trx_id的值就是1，max_trx_id的值就是4。
creator_trx_id :表示生成该 ReadView 的事务的 事务id 

我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而 是执行一个所谓的delete mark操作，
相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服 务的，大家可以对比上边举的例子自己试想一下怎么使用。 
另外，所谓的MVCC只是在我们进行普通的SEELCT查询时才生效
```
![](.z_9_mysql_03_事务_隔离级别_MVCC_锁_锁释放_readview视图_脏写_脏读_不可重复读_幻读_images/af8e4b70.png)
###READ COMMITTED生成read view时机
每次读取数据前都生成一个ReadView,使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView
例子,[mysql是怎么运行的,24.3.2]
###REPEATABLE READ生成read view时机
对于使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查 询就不会重复生成了。
例子,[mysql是怎么运行的,24.3.2]



#脏读、不可重复读、幻读解决方案
##一致性读
读操作利用多版本并发控制( MVCC )，写操作进行 加锁

采用 MVCC 方式的话， 读-写 操作彼此并不冲突，性能更高，采用 加锁 方式的话， 读-写 操 作彼此需要排队执行，影响性能。一般情况下我们当然愿意
采用 MVCC 来解决 读-写 操作并发执行的问 题，但是业务在某些特殊情况下，要求必须采用 加锁 的方式执行，
##锁定读
读、写操作都采用 加锁 
```asp
如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银 行存款的事务中，你需要先把账户的余额读出来，
然后将其加上本次存款的数额，最后再写到数据库 中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事 
务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行 加锁 操作，这样也就意味着 读 操 作和 写 操作也像 写-写 操作那样排队执行
```
##幻读
幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行
[](https://time.geekbang.org/column/article/75173)
1.可重复读隔离级别能解决读情况的幻读,不能解决改删的幻读,改删都是当前读
2.可重复读+for update gap锁+行锁,避免幻读
3.gap锁与gap锁不互斥,与插入的行锁互斥
4.非索引的可重复读+for update gap锁+行锁,会导致全表加gap锁
5.非唯一索引的gap锁
