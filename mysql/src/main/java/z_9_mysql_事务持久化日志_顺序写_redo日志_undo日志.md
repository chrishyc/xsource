##redo物理结构
```asp
redo 日志占用的空间非常小

我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来 系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在
每次事务提交时就把该事务在内存中修 改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好

存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于 redo 日志的格式我们稍后 会详细唠叨，现在只要知道一条 redo 日志占用的空间不是很大就好了

redo 日志是顺序写入磁盘的
在执行事务的过程中，每执行一条语句，就可能产生若干条 redo 日志，这些日志是按照产生的顺序写入磁
盘的，也就是使用顺序IO
```
![](.z_8_mysql_持久化_顺序写_redo日志_images/c2684c71.png)
```asp
各个部分的详细释义如下:
type :该条 redo 日志的类型。
在 MySQL 5.7.21 这个版本中，设计 InnoDB 的大叔一共为 redo 日志设计了53种不同的类型，稍后会详细介 绍不同类型的 redo 日志。
space ID :表空间ID。
page number :页号。
data :该条 redo 日志的具体内容。
```
#物理日志类型
```asp
只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥 就好了
```
![](.z_8_mysql_事务持久化日志_顺序写_redo日志_images/2a4e26d6.png)
![](.z_8_mysql_事务持久化日志_顺序写_redo日志_images/c9b1ecae.png)
![](.z_8_mysql_事务持久化日志_顺序写_redo日志_images/083145df.png)
```asp
只要将MLOG_WRITE_STRING类型的redo日志的len字段填充上1、2、4、8这些数字，就可以分别替代MLOG _1BYTE、MLOG_2BYTE、MLOG_4BYTE、MLOG_8BYTE这些类型的redo日志，
为啥还要多此一举设计这么多类 型呢?还不是因为省空间啊，能不写len字段就不写len字段，省一个字节算一个字节。
```
#redo
redo记录二级索引的日志，需要去二级索引查找页面，加载到buffer pool中
如果有多个二级索引，redo日志需要记录多个二级索引，需要从磁盘中读取对应二级索引的页面
不过因为有change buffer，所以记录change buffer的redo也行
在不在buffer pool有啥关系吗，不在就把它加载到buffer pool不就好了
#undo
