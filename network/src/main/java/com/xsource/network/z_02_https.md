#https
http+TLS,目前是 1.2
![](.z_02_https_images/49ebac61.png)
##术语
密钥,密文
##加密套件TLS
算法组合
![](.z_02_https_images/dfa25814.png)
密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法
“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。”
#5大问题
##机密性(混合加密,RSA+对称加密AES)
##完整性(摘要算法,SHA384)
##身份认证(数字签名,摘要算法+私钥加密)
使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”
就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。但又因为非对称加密效率太低，所以私钥只加密原文的摘要，
这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输
![](.z_02_https_images/6fd6ef04.png)
##不可否认(摘要算法+私钥加密)
靠数字签名解决，内容摘要算法得到摘要，私钥加密摘要，对方使用对应公钥解密，得到摘要，再和自己得到的服务器提供的原文摘要对比，
一致说明这个内容就是原服务器提供的，由证书说明了服务器的身份
##重放(nonce)
需要时间戳和随机数再合起来做一个不可逆的签名,nonce
#对称加密(AES)
AES256,密钥长度256bit
![](.z_02_https_images/835728b8.png)
##分组模式
AES128-GCM,密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM

#非对称加密(RSA)
RSA 2048

##公钥
公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密
网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，
密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。
![](.z_02_https_images/d320f5e2.png)
##私钥
##密钥交换
##数字签名(身份认证)
使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”
就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。但又因为非对称加密效率太低，所以私钥只加密原文的摘要，
这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输
![](.z_02_https_images/6fd6ef04.png)
#混合加密(RSA+AES)
可以看到，RSA 的运算速度是非常慢的，2048 位的加解密大约是 15KB/S（微秒或毫秒级），而 AES128 则是 13MB/S（纳秒级），差了几百倍
```asp

aes_128_cbc enc/dec 1000 times : 0.97ms, 13.11MB/s

rsa_1024 enc/dec 1000 times : 138.59ms, 93.80KB/s
rsa_1024/aes ratio = 143.17

rsa_2048 enc/dec 1000 times : 840.35ms, 15.47KB/s
rsa_2048/aes ratio = 868.13
```

##密钥交换(RSA非对称加密)
#摘要算法(SHA256,完整性)
摘要算法,散列函数、哈希函数
摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”
特殊的“单向”加密算法,只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文
![](.z_02_https_images/45295872.png)
真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文
![](.z_02_https_images/ccfdde93.png)
##伪随机数
输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数
#证书认证机构(CA,权威机构通过签名对个人公钥进行担保)
由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的
有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）
一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的
![](.z_02_https_images/fc92044c.png)
服务器返回的是证书链（不包括根证书，根证书预置在浏览器中），然后浏览器就可以使用信任的根证书（根公钥）解析证书链的根证书得到一级证书的公钥+摘要验签，
然后拿一级证书的公钥解密一级证书拿到二级证书的公钥和摘要验签，再然后拿二级证书的公钥解密二级证书得到服务器的公钥和摘要验签，验证过程就结束了
#https 连接流程
[](https://time.geekbang.org/column/article/110354)
ECDHE
![](.z_02_https_images/57c20fbb.png)
RSA
![](.z_02_https_images/d9943931.png)
##TLS套件版本沟通
```asp

Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Random: 1cbf803321fd2623408dfe…
    Cipher Suites (17 suites)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)
```
```asp

Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 0e6320f21bae50842e96…
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)
```
##服务端身份认证
1.浏览器内置CA证书(公钥)
2.服务端证书(服务端公钥+服务端公钥的摘要验签,验签由二级证书的公钥加密)
##交换随机数
客户端随机数+服务端随机数+pre-master-> 主密钥,会话密钥
三个不可靠的随机数混合起来，那么“随机”的程度就非常高了
###主密钥
![](.z_02_https_images/7a2b6d5a.png)
用于加密密钥的密钥被称为KEK(Key Encrypting Key)
###会话密钥
每次会话都会产生新的会话密钥，即使密钥被窃听了，也只会影响本次会话
加密的对象是用户直接使用的信息(内容)，这个时候密钥被称为CEK(Contents Encrypting Key)
##DH算法生成Pre Master Secret
[](https://halfrost.com/cipherkey/)
##随机数+pre master生成主密钥&会话密钥
##FINISHED
把之前所有发送的数据做个摘要，再加密(公钥)一下，让服务器做个验证
后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下
#OpenSSL
是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，
包括常用的 Web 服务器 Apache、Nginx 等
